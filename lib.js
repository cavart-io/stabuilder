// Generated by CoffeeScript 2.2.4
var assign, build, cleanIndexNames, dive, execSync, fileProps, filterClasses, filterFiles, filterIndexes, fm, fs, listFiles, makeMenu, mdwrapper, menu, moveAssets, noFilter, outdir, parseFM, path, prepareMD, pretty, pug, readFile, render, run, sortBy, srcdir, types, writeHtml;

({execSync} = require('child_process'));

fs = require('fs');

fm = require('front-matter');

path = require('path');

pug = require('pug');

dive = require('diveSync');

srcdir = './src';

types = ['.md', '.pug', '.mdm'];

outdir = './out';

pretty = 0;

menu = [];

mdwrapper = fs.readFileSync("./src/mdwrapper.pug", 'utf-8');

try {
  console.log('Building with stabuilder v_' + require(path.join(__dirname, 'package.json')).version);
} catch (error) {}

run = function(cmd) {
  return execSync(cmd);
};

listFiles = function(dir = './', list = [], _x = dive(dir, (err, filename) => {
    return list[list.length] = {filename};
  })) {
  return list;
};

assign = function(filter, action) {
  return function(item) {
    if (filter(item)) {
      return Object.assign(item, action(item));
    }
  };
};

sortBy = function(property, desc) {
  return function(a, b) {
    return (a[property] > b[property]) ^ desc;
  };
};

noFilter = () => {
  return true;
};

filterFiles = (types) => {
  return (item) => {
    return !item.filename.includes('README') && types.find((e) => {
      return item.filename.endsWith(e);
    });
  };
};

filterClasses = (classes) => {
  return (item) => {
    return classes.find((e) => {
      return item.fileclass.endsWith(e);
    });
  };
};

fileProps = (item, parts = item.filename.match(/(\w+)\/(\w+)\.(\w+)/i)) => {
  return {
    fileclass: parts[1],
    outfile: parts[2],
    filetype: parts[3]
  };
};

filterIndexes = (item) => {
  return item.outfile === 'index';
};

cleanIndexNames = (item) => {
  return {
    outfile: ''
  };
};

readFile = (item) => {
  return {
    content: fs.readFileSync(item.filename, 'utf-8')
  };
};

parseFM = (item) => {
  return fm(item.content);
};

prepareMD = (item) => {
  return {
    body: mdwrapper + item.body.replace(/^(.*)$/mg, (a, b) => {
      if (b.match(/^\+\w/)) {
        return `  ${a}\n  :markdown-it`;
      } else {
        return '    ' + a;
      }
    })
  };
};

makeMenu = (item) => {
  return {
    global: {
      menu: (item.attributes.menu ? [
        menu.push(Object.assign(item.attributes.menu,
        {
          path: `/${item.outfile}`
        })),
        menu
      ][1] : menu).sort(sortBy('order'))
    }
  };
};

render = (item) => {
  return {
    html: pug.render(item.body, item)
  };
};

writeHtml = (item) => {
  var dir, file;
  dir = path.join(outdir, item.outfile);
  file = path.join(dir, 'index.html');
  run(`mkdir -p ${dir}`);
  fs.writeFileSync(file, item.html);
  return console.log(`- ${file}`);
};

moveAssets = () => {
  return run(`cp -R ./static ${outdir}`);
};

build = function() {
  var list;
  list = listFiles(srcdir).filter(filterFiles(types));
  list.map(assign(noFilter, fileProps));
  list.map(assign(filterIndexes, cleanIndexNames));
  list.map(assign(noFilter, readFile));
  list.map(assign(filterFiles(['pug', 'md']), parseFM));
  list.map(assign(filterClasses(['pages']), makeMenu));
  list.map(assign(filterFiles(['md']), prepareMD));
  list.map(assign(filterClasses(['pages']), render));
  list.map(assign(filterClasses(['pages']), writeHtml));
  moveAssets();
  return list;
};

module.exports = {build};
